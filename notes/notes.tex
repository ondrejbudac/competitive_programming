\documentclass[a4paper, twoside,openany]{book}


% % GEOMETRY
%\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-1.2in}
\addtolength{\textwidth}{1.2in} %{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
\setlength{\parskip}{0.3em}
\setlength{\parindent}{0pt}

%----------------------------------------------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{listings} % Required for inserting code snippets
\usepackage[usenames,dvipsnames]{color} % Required for specifying custom colors and referring to colors by name
\usepackage{enumitem}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{titlesec}
\usepackage{lipsum}
\usepackage{marginnote}\reversemarginpar
\usepackage{collect}

% COLLECTION OF SOLUTIONS - AT THE END
\definecollection{test}
\newcounter{problem}\setcounter{problem}{0}
\newcounter{solution}\setcounter{solution}{0}

\makeatletter
\newenvironment{questionanswer}[3]{
  \newcommand{\nextpart}{ %
  		\@nameuse{collect}{test}{}{}{}{}
	  \phantomsection\label{#3:sol}
		\refstepcounter{solution}
  		\par
		\noindent
		\textbf{\thesolution. #1.}  \hfill \textbf{[\ #2\ ]}\\
		\noindent \hphantom{a}\hfill problem statement on page \pageref{#3} \\
		\par
  } 
	  \refstepcounter{problem}
	  \par
	  \noindent
	  \textbf{\theproblem. #1.}\phantomsection\label{#3}  \hfill \textbf{[\ #2\ ]}\\
	  \noindent \hphantom{a}\hfill solution on page \pageref{#3:sol}
	  \par
  }{%
  \@nameuse{endcollect}
  \bigskip
}
\makeatother


%\newenvironment{problem}[3][\unskip]{%
%\refstepcounter{problem}
%\par
%\noindent
%\textbf{\theproblem. #1.}\label{#3} \hfill \textbf{[\ #2\ ]}\\ 
%\noindent Solution on page \pageref{#3:sol} %\hyperlink{page}{#3:sol}\\
%\noindent}
%{}
%
%\newcommand{\solution}[1]{\subsubsection*{Solution to problem}\label{#1:sol}}
\newcommand{\mytag}[1]{\hyperref[#1]{#1}}

% Chapter styles
\newcommand*{\fancychapterstyle}{%
  \titleformat{\chapter}[display]{\normalfont\bfseries\filcenter}{}{1ex}{\titlerule[2pt]\vspace{2ex}\LARGE\thechapter\quad}[\vspace{1ex}{\titlerule[2pt]}]
}
\newcommand*{\standardchapterstyle}{%
  \titleformat{\chapter}[display]{\normalfont\bfseries}{}{1ex}{\LARGE}
}

% TITLE PAGE COMMAND
\newcommand*{\titleGM}{\begingroup 
\hbox{ 
\hspace*{0.2\textwidth} % Whitespace to the left of the title page
\rule{1pt}{\textheight} % Vertical line
\hspace*{0.05\textwidth} % Whitespace between the vertical line and title page text
\parbox[b]{0.75\textwidth}{ % Paragraph box which restricts text to less than the width of the page

{\noindent\Huge\bfseries Competitive \\[0.5\baselineskip] programming}\\[2\baselineskip] 
{\large \textit{a collection of algorithms,\\ problems, and solutions}}\\[4\baselineskip] 
{\Large \textsc{Ondrej Bud\'a\v c}} % Author name

\vspace{0.5\textheight} % Whitespace between the title block and the publisher
{\noindent \today}\\[\baselineskip] % Publisher and logo
}}
\endgroup}

% CUSTOM COLORS
\definecolor{commentColor}{rgb}{0.0,0.6,0.0} % Comment color
\definecolor{DarkBlue}{rgb}{0.0,0.0,0.4} % Comment color
\definecolor{keywordColor}{rgb}{0.7,0.0,0.0} % Comment color
\definecolor{highlight}{RGB}{255,251,204} % Code highlight color

% HIGHLIGHTING STYLE
\lstdefinestyle{cpp}{ % Define a style for your code snippet, multiple definitions can be made if, for example, you wish to insert multiple code snippets using different programming languages into one document
language={C++}, % Detects keywords, comments, strings, functions, etc for the language specified
%backgroundcolor=\color{highlight}, % Set the background color for the snippet - useful for highlighting
basewidth  = {.5em,0.5em},
basicstyle=\footnotesize\ttfamily, % The default font size and style of the code
breakatwhitespace=false, % If true, only allows line breaks at white space
breaklines=true, % Automatic line breaking (prevents code from protruding outside the box)
captionpos=b, % Sets the caption position: b for bottom; t for top
columns=fixed,
commentstyle=\footnotesize\ttfamily\color{commentColor}, % \usefont{T1}{pcr}{m}{sl}\color{DarkGreen}, % Style of comments within the code - dark green courier font
deletekeywords={}, % If you want to delete any keywords from the current language separate them by commas
%escapeinside={\%}, % This allows you to escape to LaTeX using the character in the bracket
firstnumber=1, % Line numbers begin at line 1
frame=leftline, % Frame around the code box, value can be: none, leftline, topline, bottomline, lines, single, shadowbox
frameround=ffff, % Rounds the corners of the frame for the top left, top right, bottom left and bottom right positions
keywordstyle=\footnotesize\ttfamily\color{keywordColor}\bfseries, % Functions are bold and blue
morekeywords={__int64}, % Add any functions no included by default here separated by commas
numbers=left, % Location of line numbers, can take the values of: none, left, right
numbersep=10pt, % Distance of line numbers from the code box
numberstyle=\footnotesize\ttfamily\color{Black}, % Style used for line numbers
rulecolor=\color{black}, % Frame border color
showstringspaces=false, % Don't put marks in string spaces
showtabs=false, % Display tabs in the code as lines
stepnumber=1, % The step distance between line numbers, i.e. how often will lines be numbered
stringstyle=\color{Purple}, % Strings are purple
tabsize=2, % Number of spaces per tab in the code
}

% Create a command to cleanly insert a snippet with the style above anywhere in the document
\newcommand{\insertcode}[2]{\begin{itemize}\item[]\lstinputlisting[caption=#2,label=#1,style=cpp]{#1}\end{itemize}} % The first argument is the script location/filename and the second is a caption for the listing

%----------------------------------------------------------------------------------------

\begin{document}

% TITLE PAGE
\pagestyle{empty} % Removes page numbers

\titleGM



\standardchapterstyle

\tableofcontents

\fancychapterstyle

\chapter{Graph algorithms}
%----------------------------------------------------------------------------------------
\section{Floyd-Warshall algorithm}\label{Floyd-Warshall}
It is a graph analysis algorithm for finding shortest paths in a weighted graph with positive or negative edge weights with \emph{no negative cycles}.
A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between all pairs of vertices, though the simple version it does not return details of the paths themselves.

The Floyd-Warshall algorithm compares all possible paths through the graph between each pair of vertices.
It is able to do this with $\Theta(|V|^3)$ comparisons in a graph. 
This is remarkable considering that there may be up to $\Omega(|V|^2)$ edges in the graph, and every combination of edges is tested. 
It does so by incrementally improving an estimate on the shortest path between two vertices, until the estimate is optimal. 

\insertcode{"codes/floyd_warshall.cpp"}{A C++ code for the Floyd-Warshall algorithm} % The first argument is the script location/filename and the second is a caption for the listing

To detect negative cycles using the Floyd-Warshall algorithm, one can inspect the diagonal of the path matrix, and the presence of a negative number indicates that the graph contains at least one negative cycle.

\subsection{Minimal path reconstruction} 
With simple modifications, it is possible to create a method to reconstruct the actual path between any two endpoint vertices. 
The Shortest-path tree can be calculated for each node in $\Theta(|E|)$ time using $\Theta(|V|)$ memory to store each tree which allows us to efficiently reconstruct a path from any two connected vertices.

\insertcode{"codes/floyd_warshall_reconstruct.cpp"}{A C++ code for the Floyd-Warshall algorithm with information about the minimal path.} 

\subsection{Widest path problem}
In graph algorithms, the \emph{widest path problem}, also known as the \emph{bottleneck shortest path problem} or the \emph{maximum capacity path problem}, is the problem of finding a path between two designated vertices in a weighted graph, maximizing the weight of the minimum-weight edge in the path.
The Floyd-Warshall algorithm can be applied to solve this problem with minor modifications.
One has to reverse the inequality and the addition operation is replaced by the minimum operation.

\insertcode{"codes/floyd_warshall_routing.cpp"}{A C++ code for the Floyd-Warshall algorithm used for optimal routing in a constrained network.} 


\section{Dijkstra's algorithm}
\label{Dijkstra}


\section{Max-flow}
\label{max-flow}

%----------------------------------------------------------------------------------------
\chapter{Practical tricks}

\section{Bitmask tricks}
\label{bitmask}

Integers can represent sets. Let $N \geq 0$ and cosider all integers in $\{ 0, 1, 2, \ldots, 2^N-1 \}$. If every place of their binary representation (of length at most $N$) is considered an indicator of an element, they can decode all possible subsets of a set with $N$ elements. For example, if $N=8$ and we consider a set $\{ 0, 1, \ldots, 7\}$, then the number $A=00100101_2$ (binary) encodes the set $\{ 0, 2, 5 \}$. We can do the following set manipulation using bit operations:

\begin{tabular}{ll}
{\lstinline[style=cpp]!A & B!} & represents set intersection\\
{\lstinline[style=cpp]!A | B!} & represents set union\\
{\lstinline[style=cpp]!A ^ B!} & represents set xor (exclusive or)\\
{\lstinline[style=cpp]!((1 << N) - 1) ^ A!} & represents set complement\\
{\lstinline[style=cpp]!A & ~(A-1)!} & is the singleton set with the smallest element of {\lstinline[style=cpp]!A!}\\
{\lstinline[style=cpp]!~(A & (A-1))!} & is a test if the set is singleton (power of $2$)\\
{\lstinline[style=cpp]!A |= 1 << i!} & adds an element\\
{\lstinline[style=cpp]!A &= ~(1 << i)!} & removes an element\\
{\lstinline[style=cpp]+(A & 1 << i) != 0+} & tests if an element is in the set\\
\end{tabular}

To get the greatest element of {\lstinline[style=cpp]!A!} one can use a function.

\insertcode{"codes/highest_set_bit.cpp"}{Find the highest set bit of a given bitmask.} 

To iterate over all subsets of the set ${0, 1, 2, \ldots, N-1}$ we can use the following code.

\insertcode{"codes/list_subsets.cpp"}{A bitmask trick to list all the subsets without recursion.} 

To iterate over all subsets of a set representet by a bitmask we can modify this algorithm to get 

\insertcode{"codes/list_subsets_of_bitmask.cpp"}{A bitmask trick to list all the subsets of a set given by a bitmask without recursion.}

When dealing with 64-bit bitmasks it is necessary to be careful with the types and use {\lstinline[style=cpp]!1LL!} instead of {\lstinline[style=cpp]!1!} in all the circumstances. Indeed {\lstinline[style=cpp]!1 << 62 = 0!} and {\lstinline[style=cpp]!1LL << 62 = 4611686018427387904!}.

%----------------------------------------------------------------------------------------

\section{Using STL}
This section will feature many tips and tricks and notes about the STL containers and algorithms.

\insertcode{"codes/STL.cpp"}{Introduction to STL}

%----------------------------------------------------------------------------------------
\chapter{Linear algebra}

\section{Gaussian elimination}
Given a set of non-negative integers $\{ a_0, a_1, \ldots, a_{N-1} \}$, find a subset that has the highest value when bitwise xor is applied to all its elements.
We perform a complete Gaussian elimination and then xor the basis vectors to get the maximum.
We keep the track of the inverse transformation of the basis in bitmasks to easily reconstruct the original subset

\insertcode{"codes/maximal_xor.cpp"}{An algorithm to find a subset of a given set with maximal bitwise xor using Gaussian elimintaion.}


%----------------------------------------------------------------------------------------

\chapter{Classical problems}
\section{Longest common subsequence}
The longest common subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences (often just two).
When only two sequences $\{ a_0, a_1, \ldots, a_{n-1}\}$ and $\{ b_0, b_1, \ldots, b_{m-1}\}$ are considered, there is a dynamic approach that solves this problem in $O(nm)$.
If $L(i,j)$ is the length of the longest common subsequence to $\{ a_0, a_1, \ldots, a_{i-1}\}$ and $\{ b_0, b_1, \ldots, b_{j-1}\}$, then we have
\begin{equation}
L(i,j) = \begin{cases} L(i-1,j-1) + 1 &  \textnormal{if } a_i = b_j\\ \max(L(i,j-1), L(i-1,j)) & \textnormal{otherwise.} \end{cases}
\end{equation}
This leads to a simple algorithm that runs in $O(mn)$ time and $O(mn)$ memory requirements. In this version of the algorithm we can extract the LCS from the dynamic table.

\insertcode{"codes/longest_common_subsequence.cpp"}{A dynanamic programming approach to the LCS problem with LCS reconstruction.}

If we only look for the length of the LCS, we don't need to store the whole table and memory requirements are only $O(\min(m,n))$.

\insertcode{"codes/longest_common_subsequence_length.cpp"}{A dynanamic programming approac to find the length of the LCS.}

\subsection{Conversion to longest increasing sequence}
For any $v$ let $L_v$  be a decreasing sequence of all indices $i$ for which $a_i = v$, that is $L_v= \{ i\in \{n-1, n-2, \ldots, 0\} : a_i = v \}$. We create a new sequence $c = L_{b_1}, L_{b_2}, \ldots, L_{b_{m-1}}$. The longest increasing sequence in $c$ has the same length as the longest common subsequence of $a$ and $b$.

Complexity of this reduction can blow up if $a$ and $b$ use a small alphabet. On the other hand, if $a$ and $b$ have unique elements, the length of $c$ is at most the length of $b$.

\subsection{Codeforces round 201, division 1, problem B}
\url{http://codeforces.com/problemset/problem/346/B}

\subsection{Codeforces round 264, division 2, problem D}
\url{http://codeforces.com/problemset/problem/463/D}

\section{Longest increasing subsequence}
Given a sequence $a_0, \ldots, a_{n-1}$, determine the greatest $L>0$ such that there is an  increasing subsequence $a_{i_1}, \ldots, a_{i_L}$.

An algorithm with time complexity $O(n \log(n))$ proceeds as follows. We iterate with $i\in \{0, \ldots, N-1\}$ and after processing $i$ we keep track of the following quantities:
\begin{enumerate}
\item[$L$] the length of the LIC in $a_0, \ldots, a_{i}$.
\item[$\{ m_j \}_{j=1}^L$] The value $m_j$ stores the index $k$ of the smallest value $a_k$ such that there is an increasing subsequence of length $j$ ending with $a_k$. 
\item[$\{ p_k \}_{k=0}^i$] The value $p_k$ stores the index of the predcessor of the LIS that ends with $a_k$.
\end{enumerate}

Note that, at any point in the algorithm, the sequence $a_{m_j}, a_{m_2}, \ldots, a_{m_L}$
is nondecreasing. This means that when we are processing $a_i$ we can use binary search to find the greatest $m \in \{ 1, ldots, L \}$ such that $a_m < a_i$.


\insertcode{"codes/longest_increasing_subsequence.cpp"}{algorithm}
%----------------------------------------------------------------------------------------

\chapter{Data structures}
\section{Disjoint-sets: Union-find}
\label{union-find}
In computing, a disjoint-set data structure, also called a union–find data structure or merge–find set, is a data structure that keeps track of a set of elements partitioned into a number of disjoint (nonoverlapping) subsets. It supports two useful operations:
\begin{enumerate}
\item[\bf find] Determine which subset a particular element is in. Find typically returns an item from this set that serves as its ``representative''; by comparing the result of two Find operations, one can determine whether two elements are in the same subset.
\item[\bf union] Join two subsets into a single subset.
\end{enumerate}

Suppose that we have $N$ different singletons, each containing one of the numbers $0, 1, \ldots, N-1$. Given is a sequence of pairs of numbers $\{(a_i, b_i)\}_{i=0}^{M-1}$ with $0 <= a_i <  N$ and $0 <= b_i <  N$, we do the following operation: For every $i \in \{0, \ldots, M-1\}$ we pick the two sets containing $a_i$ and $b_i$ and unite them. If one is interested only in the sets at the end of this process, a breadth-first search is a suitable alternative with running time $O(M+N)$. But what if we want to have information about the sets after every operation?

\insertcode{"codes/union_find.cpp"}{A union-find algorithm with only \emph{path compression}.}

\insertcode{"codes/union_find_rank.cpp"}{A union-find algorithm with \emph{path compression} and \emph{union by rank}.}


\subsection{Problem: SRM 356, division 2, hard}
Given are $N\leq 50$ nodes and $M \leq \binom{50}{2}$ edges, while some of the edges have positive weights.
Find a minimum spanning tree with minimal cost (cost is counting only over the weighted edges) or determine that there is no minimum spanning tree.

\subsection{Problem: SRM 210, division 2, hard}
Given is an grid $N \times N$ of numbers, $N \leq 50$.
At the beginning all cells of the grid are white.
We repeat the following step until all cells of the grid are black:

{\textbf{step:}} Find a white cell with the greatest number. In case of ties we choose 1. cell with smaller $y$-coordinate, 2. cell with smaller $x$-coordinate.
Color all the cells that are reachable (by moving in the 8 basic directions) from the chosen cell without ever moving to a higher number.

Determine for every step the number of cells that change color from white to black.


\section{Suffix trees}
 
 % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
 
\chapter{Examples}

%\begin{problem}[topcoder SRM 181, division 1, hard]{\mytag{Dijkstra}, \mytag{bitmask}}{srm:181:1:hard}
%Zadanie.
%\end{problem}

%\begin{atest}
%
%\end{atest}

\begin{questionanswer}{topcoder SRM 181, division 1, hard}{\mytag{Dijkstra}, \mytag{bitmask}}{srm:181:1:hard}
In a computer game, there are $N \leq 15$ bosses numbered $\{0, \ldots, N-1\}$ to defeat.
You can fight them one by one in any order you want. 
Boss number $i$ has $h_i$ life points (LP).
At the beginning you have a universal weapon that takes $1$ LP per shot from any boss.
For every boss $i$ you know that his gun takes $a_{ij} \geq 0$ LP per shot from boss $j \in \{ 1, \ldots, N-1\}$.
When life points of a boss drop to $0$ or less, you defeated him and you add his weapon to your inventory.
Your inventory is unlimited and you can use any weapon you have.
Determine the order in which you kill the bosses so that the \emph{number of shots you shoot is minimized}.
\nextpart
\insertcode{"codes/Dijkstra_SRM181div1hard.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{topcoder SRM 150, division 1, hard}{\mytag{Dijkstra}}{srm:150:1:hard}
You are given a path of the robot Alex as a string containing only characters $L$ (turn $60$ degrees left), $R$ (turn $60$ degrees right), and $F$ (move $1$ meter forward).
When Alex has finished his movements, the robot Boris starts in the exact position (and rotation) as Alex.
Boris' goal is to get to Alex in such a way, that whenever he is moving forward, he must be in Alex's tracks.
It takes $3$ seconds to turn left or right by $60$ degrees.
Going forward one meter takes $4$ seconds, going forward two meters takes $8$ seconds, but for $n>2$ Boris can use the momentum and move $n$ meters forward (without turning) in only $8+2(n-2)$ seconds.
Calculate the minimal time Boris needs to get to the final destination of Alex.
\nextpart
\insertcode{"codes/Dijkstra_SRM150div1hard.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{topcoder SRM 632, division 1, medium}{\mytag{union-find}, \mytag{max-flow}}{srm:632:1:medium}
Given is a graph with $N \leq 2000$ nodes labelled $0, 1, \ldots, N-1$ and $M \leq 2000$ non-oriented edges labelled $0, 1, \ldots, M-1$. 
The edge with label $i$ has capacity $3^i$. 
Find maximal flow between vertices $0$ and $N-1$.
Return the result modulo $1000000007$.
\nextpart
\insertcode{"codes/CandyCupRunningCompetition.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{topcoder SRM 631, division 1, medium}{greedy}{srm:631:1:medium}
Given is $N \in \mathbb{N}$ with $N \leq 1000$ and numbers $p_i \in \mathbb{Z}, c_i \in \mathbb{N}_0$ for  $i \in \{0, \ldots, N-1\}$.
At position $p_i$ on a line we have $c_i$ cats for every $i \in \{0, \ldots, N-1\}$.
Every minute, each cat sitting at a point $p$ has three choices: (1) stay at $p$, (2) move to $p+1$, (3) move to $p-1$.
Return minimal possible number of points on a line where more than one cat sits after $T \in \mathbb{N}$ minutes.
\nextpart
\insertcode{"codes/CatsOnTheLineDiv1.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{topcoder SRM 630, division 1, medium}{greedy}{srm:630:1:medium}
Given is a suffix array of length $N \leq 50$.
Return the smallest possible number of different characters that can produce a string with this suffix array.
\nextpart
\insertcode{"codes/SuffixArrayDiv1.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{codeforces round 265, division 1, A}{greedy}{cf:265:1:A}
Given is $p \in \{1, \ldots, 26\}$.
A string is called tolerable if it contains only one of the first $p$ letters of the English alphabet and it doesn't contain any palindromatic substring of length $2$ or more.
Given a tolerable string $s$ of length $n \leq 1000$, find the lexicographically next tolerable string of the same length or state that such string does not exist.
\nextpart
\insertcode{"codes/codeforces265div1A.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{codeforces round 265, division 1, B}{greedy}{cf:265:1:B}
Given is a table $8 \times 3$ of integers less than $10^6$ in absolute value. 
Can one permute every line ($8$ lines), so that the triplets in lines can be coordinates of vertices of a cube in $\mathbb{R}^3$?
Edges of such a cube do not have to be parallel to the axes.
If yes, write one such permutation.
\nextpart
\insertcode{"codes/codeforces265div1B.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{codeforces round 265, division 1, C}{modulo, dp}{cf:265:1:C}

\nextpart
\insertcode{"codes/codeforces265div1C.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{codeforces round 266, division 2, D}{modulo, dp}{cf:266:1:D}
todo
\nextpart
\insertcode{"codes/codeforces266div2D.cpp"}{todo}
\end{questionanswer}

\begin{questionanswer}{codeforces round 266, division 2, E}{dfs, \mytag{union-find}, queries}{cf:266:2:E}
todo
\nextpart
\insertcode{"codes/codeforces266div2E.cpp"}{todo}
\end{questionanswer}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Solutions}
 \includecollection{test}
 

\end{document}